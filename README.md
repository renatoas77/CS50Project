SUPER SHOTGUN BROH

Video Demo: [Super Shotgun Broh](https://www.youtube.com/watch?v=Nvz6269tfv4)

Godot Engine Introduction

Godot is a free, open source game engine, developed and maintained by the Godot Foundation, distributed under the MIT license, which means that in addition to being free, anyone can have access to the program's source code and make any changes they deem necessary. The Engine supports both 2D and 3D, supports the following languages: GDScript, C# and C++ and its projects can be exported to different platforms such as Windows, Linux, Android, etc.  
One of the most basic operating units in Godot are Nodes, Nodes are small components capable of performing different functions and that can be combined with other Nodes to generate more complex behaviors, there are several types of Nodes with different functions, such as showing an image, play a sound, detect collisions and various things commonly used in games. All Nodes have a name, editable properties, can be manipulated via code, can and should be combined to achieve more complex behaviors. When several Nodes are combined we have what we call a Scene, and just like Nodes, Scenes can also be combined. We can, for example, combine the animation and collision Nodes to create a character that will be controlled via code, as the character is a combination of Nodes it is what can be called a Scene, we can also use the image, collision and sound Nodes to create a scenario, which will also be a Scene and in the same way that we can combine Nodes to achieve more complex behaviors we can combine Scenes, for example, the character Scene and the scenery so we will have a character controlled by code that can move by the scenario, or we can combine other Nodes to make a new scenario and combine this new scenario with the character already created, by combining Scenes we have what is called a Tree. In short, by combining Nodes we create Scenes and by creating Scenes we create Trees and putting all this together we will have a Game. Another concept that we need to understand are signals, signals work as a means of communication between Nodes allowing a Node to notify one or more Nodes when something happens and then react to that event, for example let's suppose we have an animation Node and we want that a sound is emitted at the end of the animation, we can then connect the animation Node to the sound Node, when the animation ends the signal will be activated warning all connected Nodes, in this case the sound Node will be notified that the animation has ended and then may react accordingly in this case by playing a sound.  

Global  
Some variables and functions need to be accessed and maintained throughout the game, for example, the variables that control the player's number of lives and their points. For this, Godot allows us to create a Global scope class, which can be accessed anywhere in our project and is also loaded automatically as soon as we run our project. We will call this class Global, and its variables and functions will be explained throughout this project according to your needs.  

Project Introduction

When starting the project we are faced with the following screen: Image Placeholder

It is a Scene composed of the following Nodes, Node2D(Intro) which is a base Node with no function that will serve as a root Node, Sprite2D which is responsible for displaying the image on the screen (made by me in paint) and its characteristics, Camera2D which controls what the player can or cannot see and finally we have the AnimationPlayer Node, this allows us to control characteristics of other Nodes over time so that we can create animations. Using the Animation Player Node we will control the “modulate” property of the Sprite2D Node to change the color of the displayed image, alternating from its normal state to being completely black and then to its normal state again in a loop.  
To control this Scene we have a Script called Intro.gd, in the first line we see that it inherits the properties of the Node class, in the third we use the preload function to load the next Scene to be displayed, for this we will pass the Scene address as a parameter to be loaded, we will save the loading in the created variable “game_opening”.  
Next on line 5 we have the _process(_delta) function: which is responsible for running our code with each game loop executed, on line 6 we will use the is_action_just_pressed("Space") function of the Input class, to check if the space key was pressed, then in each game loop we check if it was pressed, if it was, the function returns a boolean with the value true and otherwise with the value false. Along with this, we can use an IF function to check whether the space key was pressed and if so, it will perform the function below: get_tree().change_scene_to_packed(game_opening), this function accesses the Scene tree and changes the current Scene to the Scene loaded and stored in the game_opening variable.  
When starting the game, the first thing we need to do is teach the player the controls. And for this we will use the same nodes used previously, first we will use a 2d node to group and control the other nodes, then we will use the Sprite2D node to display an image created by me containing the game instructions, we will also use the camera2d node to control the player's vision and finally we will use the timer node to control how long the image will be displayed on the screen.

Imageplaceholder  

With all the necessary nodes, we will now use code to control the Scene. The name of the script is SSBIntro.gd in the first line we see that the Script inherits some properties from Node2D, in line 3 we use the preload function to load the next Scene and store this Scene in the next_scene variable.  On line 5 we have the _on_timer_timeout() function: this function is triggered by the timer as soon as the time defined in it ends, the role of this function is to access our Global class and define the player's level, in this case 0, and also change the IntroSSB Scene for our next phase using the get_tree().change_scene_to_packed(next_scene) function.  

The character

Our game will be a parody of two well-known games: Super Mario Bros and VVVVVV, our first step will be to create the main character. To do this, we will first use a node2D to group the other nodes that we will need to use, the main node of our character will be the ChartacterBody2D, this node is a class used for physical bodies that will be controlled and already have some methods to deal with movement and collision, however, so that we can collide with other bodies in our game we must first give a collision shape and size to our character, for this we will use the CollisionShape2D node this node provides a 2D format for collision detection and must be used in set with Area2D or physical body nodes such as our CharacterBody2D, allowing it to collide with other objects such as floors, walls, platforms and more. To display our character's image to the player we will use the AnimateSprite2D node. This node allows us to load several images and control them over time so that we can create and control different animations and bring our character to life, all images of the game character they were made by me and their animations include: walking, running, jumping, falling, shooting in 3 directions (forward, down and up) and transforming, in total we have 3 different versions of each animation, except for the transformation which only has 2 versions and each of the 3 versions represents a power level of our character, all these animations will be controlled and displayed through 3 nodes of the AnimatedSprite2D type, the name of each one being:
Level1, Level2 e Level3. We will also use the AnimationPlayer node which is capable of controlling the characteristics of other nodes over time to create our victory animation, for this we will use the AnimationPlayer to control the characteristics, position and rotation of our character's AnimatedSprite2D nodes, simply manipulating the height on the axis Y and rotation, we were able to create a Backflip animation for our character.  

Our character also emits sounds and for this we will use the AudioStreamPlayer2D node, which is a node with the ability to emit and control sound in a 2D space, which can make the sound quieter or louder depending on the distance at which it sound is heard. Using 8 nodes of this type we will be able to emit 3 different types of shooting sounds, one for each level of our character, jumping sound, getting hurt sound, being defeated sound, Power up sound and gravity change sound. Lastly, we need to be able to see our character wherever he goes, for this we will attach the Camera2D node to it, which is responsible for what the player sees on the screen, as the camera is a node related to our CharacterBody2D, its position will be automatically linked to it. So we finish composing our character with all the necessary nodes, even with all these nodes performing a good number of functions, our character is nothing more than a static image with little or no interactivity. To make our character more interesting and interactive, we will use code to make it respond to the player's commands and manipulate the characteristics of the nodes, giving the impression of being a living and responsive character.  
To do this we will create a script called: PlatformerPlayer.gd it will be responsible for controlling our character, our code inherits from the CharacterBody2D class thus giving us access and control over its characteristics, below we have all the variables used in our character.  
The variables downgrades1, downgrades2, shoot1, shoot2, and shoot3 store scenes created by me (which will be explained later) and allow me to instantiate them when necessary, downgrades1 and downgrades2 will be used when the character is hitted and goes level down, will be created in the scene a weapon coming out of the player spinning in the air, the shoot variables will allow our character to shoot and cause damage to opponents. The PackedScene type shoots variable will be used to control the shot that the character will use depending on his power level, 'sounds' will be used to control the sound of the weapon, 'shoot_power' will be used to determine the strength of the recoil, 'power_upgrade ' will be used to control the upgrade of the recoil force, 'is_controler_on' will determine whether or not the player can control the character, 'animation_lock_timer' will serve as a timer, shotgun_shoot_time' will be used to determine the time that the character will be without power if move after shooting, 'deceleration ' and 'acceleration' will determine the character's acceleration and deceleration as he moves, 'max_speed' controls maximum movement speed, 'jump_force' is the character's jump impulse force, 'gravity' as the name says it is the force of gravity, 'run_right_time' and 'run_left_time' will serve as timers to control the run, 'double_tap_time' controls the run activation time, 'is_flipped_h' and 'is_flipped_v', will control whether the character is flipped horizontally or vertically, 'shoot_flash_time' controls how long the flash lasts on the screen after shooting, 'shoot_distance' will be used to control how far the shot will appear from the character, 'current_animation: AnimatedSprite2D' and 'current_sound: AudioStreamPlayer2D' will control which animations and sounds will be used depending on the character's level, 'animations: Array' will be responsible for storing the 3 different types of animations, 'death_hop' controls the strength of the jump when the character dies, 'jump_buffer' will be used as a timer to control the jump and ' buffer_timer' the available time, 'is_jump_buffered' will store whether the player wants to jump, 'coyote_time' defines the time the player can jump even after leaving the platform, 'timer_coyote' will be used as a control timer, 'is_coyote_time' defines whether the player can or cannot jump and lastly 'gravity_shift_on' will control whether or not the player can invert gravity.  

Gameloop and Delta  

Before we proceed we need to understand two concepts, game loop and delta.  Generally games take place within a loop, first all the calculations and logical processing for the game to function occur and finally, from the data obtained, an image (frame) is generated that is displayed to the player, this entire process takes a few milliseconds and occurs multiple times during one second, the minimum desirable being 30 times per second so that the image can be fluid and in some cases reaching more than 300 times per second, but this number varies depending on the complexity of the code and the power of the machine executing it. The Godot engine provides two methods to control the game loop of our game: _process(delta) and _physics_process(delta).  
Now I will explain what the delta seen in both functions is, as previously explained a game occurs within a loop and the delta parameter is the time that the previous loop (_process or _physics_process) took to execute in seconds, this is useful Because when we are programming a game we need to take time into account, understanding the meaning of the delta parameter we will proceed to explain each function. The _process(delta) function allows the code to be executed as quickly as possible, in _physicis_process(delta) the code is executed by default 60 times per second, however this number of loops can be changed in the Engine as necessary, the important thing is understand that this function will always be executed a fixed number of times within one second. As the _process() function is executed as many times as possible within a second, it is generally used to run the majority of loops, however, due to its nature, its delta always ends up varying, which in turn makes it contraindicated in physical calculations that are time-sensitive, since a variable delta makes the calculation inconsistent and that is why we have the _physics_process() function which, as its name already indicates, is recommended for carrying out time-sensitive physical calculations, such as gravity and acceleration , due to having a fixed number of executions per second (60 times) the value of its delta is fixed (1 second / 60 = 0.016666...7 seconds). Having understood how it works, let's now understand its use cases, in general games are made to run on several different platforms, with different performance and conditions, this means that execution performance will vary from one platform to another and this can cause problems when we try simulate movement, to illustrate let's give an example, let's assume that the game executes the following code “position = position + 40”, which makes the player move 40 pixels, now let's imagine that we have two computers A and B, computer A is faster and can execute 60 frames per second (let's call it that instead of game loop for simplicity), and computer B runs the same game at 30 frames per second, in this case we will have a problem since computer A runs the code 60 times per second we would have the following result ( 40 * 60 = 2400) on computer B, which has only half the speed we would have (40 * 30 = 1200), this happens for 2 reasons, firstly our code is sensitive to the number of frames, that is, the more frames the computer can execute, the more fast the player moves, To solve this situation we have to make our code time sensitive, to do this we just need to multiply the speed by delta since delta is the time (in seconds) that the previous loop took to execute the faster the execution the smaller the delta, let's see the following example: computer 'A' 60 frames per second, to find out the delta value we will divide one second by the number of frames (1 second / 60 frames = 0.01666...7) that is, delta is equal to 0, 01666...7 and updating the previous code we have “position = position + 40 * delta”, doing the math 40 * 0.01666...7 = 0.66668, that is, with each loop the player moves 0.66668 pixels to know how much it moves in a second we multiply by the number of frames 60 * 0.66668 = 40.0008 that is 40 pixels per second let's now see on the computer B frames (1 second / 30 frames = 0.0333...3) that is delta is equal to 0.333...3, using the updated code “position = position + 40 * delta”, 40 * 0.0333...3 we have 1.333332 pixels per frame and multiplying by the number of frames (30 * 1, 333332) we have 39.99996 frames per second. In this way we can see that when using delta the player moves proportionally to time since the higher the game loop execution speed of a computer, the lower the delta value and the lower the movement that occurs, in this way the player's movement speed is practically the same regardless of the speed of execution of the game loop.
