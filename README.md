SUPER SHOTGUN BROH

Video Demo: [Super Shotgun Broh](https://www.youtube.com/watch?v=Nvz6269tfv4)

Godot Engine Introduction

Godot is a free, open source game engine, developed and maintained by the Godot Foundation, distributed under the MIT license, which means that in addition to being free, anyone can have access to the program's source code and make any changes they deem necessary. The Engine supports both 2D and 3D, supports the following languages: GDScript, C# and C++ and its projects can be exported to different platforms such as Windows, Linux, Android, etc.  
One of the most basic operating units in Godot are Nodes, Nodes are small components capable of performing different functions and that can be combined with other Nodes to generate more complex behaviors, there are several types of Nodes with different functions, such as showing an image, play a sound, detect collisions and various things commonly used in games. All Nodes have a name, editable properties, can be manipulated via code, can and should be combined to achieve more complex behaviors. When several Nodes are combined we have what we call a Scene, and just like Nodes, Scenes can also be combined. We can, for example, combine the animation and collision Nodes to create a character that will be controlled via code, as the character is a combination of Nodes it is what can be called a Scene, we can also use the image, collision and sound Nodes to create a scenario, which will also be a Scene and in the same way that we can combine Nodes to achieve more complex behaviors we can combine Scenes, for example, the character Scene and the scenery so we will have a character controlled by code that can move by the scenario, or we can combine other Nodes to make a new scenario and combine this new scenario with the character already created, by combining Scenes we have what is called a Tree. In short, by combining Nodes we create Scenes and by creating Scenes we create Trees and putting all this together we will have a Game. Another concept that we need to understand are signals, signals work as a means of communication between Nodes allowing a Node to notify one or more Nodes when something happens and then react to that event, for example let's suppose we have an animation Node and we want that a sound is emitted at the end of the animation, we can then connect the animation Node to the sound Node, when the animation ends the signal will be activated warning all connected Nodes, in this case the sound Node will be notified that the animation has ended and then may react accordingly in this case by playing a sound.  

Global  
Some variables and functions need to be accessed and maintained throughout the game, for example, the variables that control the player's number of lives and their points. For this, Godot allows us to create a Global scope class, which can be accessed anywhere in our project and is also loaded automatically as soon as we run our project. We will call this class Global, and its variables and functions will be explained throughout this project according to your needs.  

Project Introduction

When starting the project we are faced with the following screen: Image Placeholder

It is a Scene composed of the following Nodes, Node2D(Intro) which is a base Node with no function that will serve as a root Node, Sprite2D which is responsible for displaying the image on the screen (made by me in paint) and its characteristics, Camera2D which controls what the player can or cannot see and finally we have the AnimationPlayer Node, this allows us to control characteristics of other Nodes over time so that we can create animations. Using the Animation Player Node we will control the “modulate” property of the Sprite2D Node to change the color of the displayed image, alternating from its normal state to being completely black and then to its normal state again in a loop.  
To control this Scene we have a Script called Intro.gd, in the first line we see that it inherits the properties of the Node class, in the third we use the preload function to load the next Scene to be displayed, for this we will pass the Scene address as a parameter to be loaded, we will save the loading in the created variable “game_opening”.  
Next on line 5 we have the _process(_delta) function: which is responsible for running our code with each game loop executed, on line 6 we will use the is_action_just_pressed("Space") function of the Input class, to check if the space key was pressed, then in each game loop we check if it was pressed, if it was, the function returns a boolean with the value true and otherwise with the value false. Along with this, we can use an IF function to check whether the space key was pressed and if so, it will perform the function below: get_tree().change_scene_to_packed(game_opening), this function accesses the Scene tree and changes the current Scene to the Scene loaded and stored in the game_opening variable.  
When starting the game, the first thing we need to do is teach the player the controls. And for this we will use the same nodes used previously, first we will use a 2d node to group and control the other nodes, then we will use the Sprite2D node to display an image created by me containing the game instructions, we will also use the camera2d node to control the player's vision and finally we will use the timer node to control how long the image will be displayed on the screen.

Imageplaceholder  

With all the necessary nodes, we will now use code to control the Scene. The name of the script is SSBIntro.gd in the first line we see that the Script inherits some properties from Node2D, in line 3 we use the preload function to load the next Scene and store this Scene in the next_scene variable.  On line 5 we have the _on_timer_timeout() function: this function is triggered by the timer as soon as the time defined in it ends, the role of this function is to access our Global class and define the player's level, in this case 0, and also change the IntroSSB Scene for our next phase using the get_tree().change_scene_to_packed(next_scene) function.  

The character

Our game will be a parody of two well-known games: Super Mario Bros and VVVVVV, our first step will be to create the main character. To do this, we will first use a node2D to group the other nodes that we will need to use, the main node of our character will be the ChartacterBody2D, this node is a class used for physical bodies that will be controlled and already have some methods to deal with movement and collision, however, so that we can collide with other bodies in our game we must first give a collision shape and size to our character, for this we will use the CollisionShape2D node this node provides a 2D format for collision detection and must be used in set with Area2D or physical body nodes such as our CharacterBody2D, allowing it to collide with other objects such as floors, walls, platforms and more. To display our character's image to the player we will use the AnimateSprite2D node. This node allows us to load several images and control them over time so that we can create and control different animations and bring our character to life, all images of the game character they were made by me and their animations include: walking, running, jumping, falling, shooting in 3 directions (forward, down and up) and transforming, in total we have 3 different versions of each animation, except for the transformation which only has 2 versions and each of the 3 versions represents a power level of our character, all these animations will be controlled and displayed through 3 nodes of the AnimatedSprite2D type, the name of each one being:
Level1, Level2 e Level3. We will also use the AnimationPlayer node which is capable of controlling the characteristics of other nodes over time to create our victory animation, for this we will use the AnimationPlayer to control the characteristics, position and rotation of our character's AnimatedSprite2D nodes, simply manipulating the height on the axis Y and rotation, we were able to create a Backflip animation for our character.  

Our character also emits sounds and for this we will use the AudioStreamPlayer2D node, which is a node with the ability to emit and control sound in a 2D space, which can make the sound quieter or louder depending on the distance at which it sound is heard. Using 8 nodes of this type we will be able to emit 3 different types of shooting sounds, one for each level of our character, jumping sound, getting hurt sound, being defeated sound, Power up sound and gravity change sound. Lastly, we need to be able to see our character wherever he goes, for this we will attach the Camera2D node to it, which is responsible for what the player sees on the screen, as the camera is a node related to our CharacterBody2D, its position will be automatically linked to it. So we finish composing our character with all the necessary nodes, even with all these nodes performing a good number of functions, our character is nothing more than a static image with little or no interactivity. To make our character more interesting and interactive, we will use code to make it respond to the player's commands and manipulate the characteristics of the nodes, giving the impression of being a living and responsive character.  
To do this we will create a script called: PlatformerPlayer.gd it will be responsible for controlling our character, our code inherits from the CharacterBody2D class thus giving us access and control over its characteristics, below we have all the variables used in our character.  
The variables downgrades1, downgrades2, shoot1, shoot2, and shoot3 store scenes created by me (which will be explained later) and allow me to instantiate them when necessary, downgrades1 and downgrades2 will be used when the character is hitted and goes level down, will be created in the scene a weapon coming out of the player spinning in the air, the shoot variables will allow our character to shoot and cause damage to opponents. The PackedScene type shoots variable will be used to control the shot that the character will use depending on his power level, 'sounds' will be used to control the sound of the weapon, 'shoot_power' will be used to determine the strength of the recoil, 'power_upgrade ' will be used to control the upgrade of the recoil force, 'is_controler_on' will determine whether or not the player can control the character, 'animation_lock_timer' will serve as a timer, shotgun_shoot_time' will be used to determine the time that the character will be without power if move after shooting, 'deceleration ' and 'acceleration' will determine the character's acceleration and deceleration as he moves, 'max_speed' controls maximum movement speed, 'jump_force' is the character's jump impulse force, 'gravity' as the name says it is the force of gravity, 'run_right_time' and 'run_left_time' will serve as timers to control the run, 'double_tap_time' controls the run activation time, 'is_flipped_h' and 'is_flipped_v', will control whether the character is flipped horizontally or vertically, 'shoot_flash_time' controls how long the flash lasts on the screen after shooting, 'shoot_distance' will be used to control how far the shot will appear from the character, 'current_animation: AnimatedSprite2D' and 'current_sound: AudioStreamPlayer2D' will control which animations and sounds will be used depending on the character's level, 'animations: Array' will be responsible for storing the 3 different types of animations, 'death_hop' controls the strength of the jump when the character dies, 'jump_buffer' will be used as a timer to control the jump and ' buffer_timer' the available time, 'is_jump_buffered' will store whether the player wants to jump, 'coyote_time' defines the time the player can jump even after leaving the platform, 'timer_coyote' will be used as a control timer, 'is_coyote_time' defines whether the player can or cannot jump and lastly 'gravity_shift_on' will control whether or not the player can invert gravity.  

Gameloop and Delta  

Before we proceed we need to understand two concepts, game loop and delta.  Generally games take place within a loop, first all the calculations and logical processing for the game to function occur and finally, from the data obtained, an image (frame) is generated that is displayed to the player, this entire process takes a few milliseconds and occurs multiple times during one second, the minimum desirable being 30 times per second so that the image can be fluid and in some cases reaching more than 300 times per second, but this number varies depending on the complexity of the code and the power of the machine executing it. The Godot engine provides two methods to control the game loop of our game: _process(delta) and _physics_process(delta).  
Now I will explain what the delta seen in both functions is, as previously explained a game occurs within a loop and the delta parameter is the time that the previous loop (_process or _physics_process) took to execute in seconds, this is useful Because when we are programming a game we need to take time into account, understanding the meaning of the delta parameter we will proceed to explain each function. The _process(delta) function allows the code to be executed as quickly as possible, in _physicis_process(delta) the code is executed by default 60 times per second, however this number of loops can be changed in the Engine as necessary, the important thing is understand that this function will always be executed a fixed number of times within one second. As the _process() function is executed as many times as possible within a second, it is generally used to run the majority of loops, however, due to its nature, its delta always ends up varying, which in turn makes it contraindicated in physical calculations that are time-sensitive, since a variable delta makes the calculation inconsistent and that is why we have the _physics_process() function which, as its name already indicates, is recommended for carrying out time-sensitive physical calculations, such as gravity and acceleration , due to having a fixed number of executions per second (60 times) the value of its delta is fixed (1 second / 60 = 0.016666...7 seconds). Having understood how it works, let's now understand its use cases, in general games are made to run on several different platforms, with different performance and conditions, this means that execution performance will vary from one platform to another and this can cause problems when we try simulate movement, to illustrate let's give an example, let's assume that the game executes the following code “position = position + 40”, which makes the player move 40 pixels, now let's imagine that we have two computers A and B, computer A is faster and can execute 60 frames per second (let's call it that instead of game loop for simplicity), and computer B runs the same game at 30 frames per second, in this case we will have a problem since computer A runs the code 60 times per second we would have the following result ( 40 * 60 = 2400) on computer B, which has only half the speed we would have (40 * 30 = 1200), this happens for 2 reasons, firstly our code is sensitive to the number of frames, that is, the more frames the computer can execute, the more fast the player moves, To solve this situation we have to make our code time sensitive, to do this we just need to multiply the speed by delta since delta is the time (in seconds) that the previous loop took to execute the faster the execution the smaller the delta, let's see the following example: computer 'A' 60 frames per second, to find out the delta value we will divide one second by the number of frames (1 second / 60 frames = 0.01666...7) that is, delta is equal to 0, 01666...7 and updating the previous code we have “position = position + 40 * delta”, doing the math 40 * 0.01666...7 = 0.66668, that is, with each loop the player moves 0.66668 pixels to know how much it moves in a second we multiply by the number of frames 60 * 0.66668 = 40.0008 that is 40 pixels per second let's now see on the computer B frames (1 second / 30 frames = 0.0333...3) that is delta is equal to 0.333...3, using the updated code “position = position + 40 * delta”, 40 * 0.0333...3 we have 1.333332 pixels per frame and multiplying by the number of frames (30 * 1, 333332) we have 39.99996 frames per second. In this way we can see that when using delta the player moves proportionally to time since the higher the game loop execution speed of a computer, the lower the delta value and the lower the movement that occurs, in this way the player's movement speed is practically the same regardless of the speed of execution of the game loop.

Player Logic  

In order to simplify our character's logic, we will create all of its logic using the _physics_process() function, since the character's functions will have time-sensitive physics calculations. All of our character's functions are controlled by 7 main functions: apply_forces(delta), buffer_jump(delta), get_coyote_time(delta), shift_gravity(), move_player(delta), jump() and activate_shoot(). First, the apply_forces() function, has the function of applying the basic forces, the first of which is using the move_and_slide() function, inherited from the CharacterBody2D class, this function causes our character to move according to the velocity attribute of the same class, this attribute is a Vector2 with 2 values ​​x and y representing respectively the horizontal and vertical speed of the character, when we call this function our character can slide across a surface to move and depending on the angle of the collision with the character the function can prevent the character from moving canceling its speed, for example when moving from one side to the other on a surface the character slides on the ground, but when moving against a wall the character stops moving due to the angle of collision between the 2 objects , or when falling to the ground, the move_and_slide() function resets our vertical speed when colliding with the ground. Next we have the apply_deceleration(delta) function, it causes the character to decelerate when they stop walking or running, it works by checking if the horizontal speed is different from zero, then it checks if when applying the deceleration the speed will change from direction, if it doesn't change we apply it to decelerate the character and if it changes, we simply reset the speed to zero, for example if the current speed is 20 and we apply 30 deceleration we will have -10 speed which is not desired, because instead of stopping the character we would be making him accelerate in opposite directions never actually stopping, so instead of slowing down we set the speed to 0. In the last line we have the application of gravity to the character's vertical speed multiplied by the gravity scale, this scale can be used to change the force of gravity by increasing or decreasing, but in our case we will only use it to invert its direction, in short: apply_forces(delta) function is responsible for applying multiple forces directly to our character such as acceleration, deceleration and gravity.  
Next we have the buffer_jump(delta) function, in some situations the player wants to jump when it is not yet possible, for example, the player has just performed a jump and immediately after touching the ground he wants to jump again, but what happens is that the player presses the jump button just before contact with the ground when it is not possible to jump, however what the player realizes is that the command was given at the correct time but was not executed, giving the feeling that the game has controls non-responsive, to solve this we store the player's command for a brief moment and execute it as soon as possible. The function works by checking when the player presses the jump command, as soon as this is done we store the intention to jump in the is_jump_buffered variable, and we add the time that this command should be registered to the jump_buffer variable, at the top we check if there is still available time, if so, we subtract delta (past loop time) from the remaining time to jump and if there is no time left, we set the variable is_jump_buffered to false, after all we do not want the jump intention to be recorded forever.  
The get_coyote_time(delta) function works similar to the previous one, in platform games, the player often wants to make long jumps to reach a distant objective, for this the player usually runs and then jumps at the last moment when the ground ends, however, several times what ends up happening is that the player ends up giving the command too late when he is no longer on the ground, but again what is perceived by the player is that the action was done at the right time but the command was not executed, to resolve this, we use a technique called coyote time, it works by making it possible to jump for a brief moment even after leaving the ground (if you haven't left the ground because you jumped, of course). In the case of our game where it is possible to invert gravity, the function checks if the gravity scale is positive and if the player is on the ground with the is_on_floor() function or if gravity is negative and the player is on the ceiling (which in the case of inverted gravity works as a kind of ground) and if so we store the time the player still has to jump in the timer_coyote variable and we make it possible to jump by setting the is_coyote_time variable to true and we return from the function this way whenever we are on the ground or ceiling it is possible jump, finally when leaving the ground the function starts subtracting the remaining time to jump if there is still time and if there is no more time remaining we set the is_coyote_time variable to false making it no longer possible to jump.  
Next we have the shift_gravity() function responsible for inverting gravity in the game, first we check if the player is on the floor or on the ceiling with the variable is_coyote_time, we also check if the command to invert gravity was triggered using the command Input.is_action_just_pressed( "shift") and lastly, as the ability to invert gravity is not active at all levels, we check if it is active using the variable gravity_shift_on, if the three conditions are true, we invert gravity by multiplying the global variable gravity_scale by -1, we invert our character's animations to match gravity, we disable coyote time by changing the variables is_coyote_time to false and coyote_time to 0.0 and finally we play the sound corresponding to the effect of our ability.  
Below are some functions responsible for reading and responding to player commands, first we check if the control is on with the variable is_controle_on, then we check if there is not an active animation lock with the variable animation_lock_timer, if so we reduce the time of this lock by subtracting delta of the remaining time, otherwise we can read the player's commands normally using the following functions. The move_player(delta) function is responsible for the movement of our character so that he can walk and run, with the command Input.is_action_pressed("right") we check if the player is pressing the button to walk to the right we also check if the player pressed the button twice with the intention of running using the run_right_time variable, if both conditions are met we first keep the run_right_time variable time at maximum so that the player can continue running as long as they keep the same button pressed, then we set the is_flipped_h variable to false , this way our animations will be oriented to the right, we also update the direction of our current animation with the variable current_animation.flip_h, we change the animation to running and play it, and finally we check that when adding the acceleration multiplied by delta we will not exceed the speed maximum running speed (Max_speed *2), if positive we add the acceleration to the current speed, otherwise we define the player's speed as the maximum running speed, this way we will never exceed the limit speed, we do the same procedures for the left side in line 259.  
Next we have the jump() function which is responsible for making the character jump, this function is extremely simple, first it is checked whether there is the intention to jump using the is_jump_buffered variable and also whether it is possible to jump using the is_coyote_time variable, if both requirements are satisfied we apply the jump force multiplied by the global gravity scale (Global.gravity_scale) to the player's vertical speed (velocity.y), so regardless of gravity the player will always jump in the correct direction, as the jump was executed successfully we must reset the time remaining to jump in both jump_buffer and coyote_time, this way we will prevent the player from jumping 2 times. Finally, we execute the $jump.play() function that makes the player emit the jump sound.  
Lastly we have the activate_shoot() function responsible for making the character shoot, it works by first choosing a random tone between 0.8 and 1.2 for the current sound of our shot, it checks whether the shoot button and any directional button were pressed together. , if a vertical direction has been chosen, we also check the gravity scale so that the character can execute the correct animation, since the character can be upside down, checking the direction we choose the appropriate animation and emit the sound corresponding to the shot, then we use the instantiate_shoot() function to create the shot, this function receives a direction in Vector2 format, then according to this direction the shot is rotated, positioned and instantiated. We add the strength of the shot (Shoot_power) to the character's speed, so that the shooting animation is not canceled prematurely with another animation, we lock the animation using the animation_lock_timer variable, we use the Global.ShakeCamera() function to make the camera shake, and finally we change the value of Global.flash_time to activate the flash.  
There are some functions that are part of the character, but are not directly controlled by the player and we will address them now. The first function we will cover is death() which is activated when the character is defeated, this function first plays the defeat sound, turns off the player's control, disables the character's collision so that he does not interact with anything else, using the function “await get_tree().create_timer(3,true,false,false).timeout” we create a 3-second timer that causes the code below to only be executed after the timer has ended, lastly calling the Global function. death() which is responsible for taking the player's lives or for calling the game over and with the function “get_tree().reload_current_scene()” we restart the phase if the game over has not occurred.  
The win_game() function is activated when the player reaches the end of a phase, it is responsible for executing the character's victory animation, first the player's control is turned off, then his speed is reset, then we update the side so that the character must be positioned and its animation, lastly with the await function get_tree().create_timer(1).timeout we create a one second timer that only when finished executes the animation with the function $AnimationPlayer.play("WinAnimation") making the character do a backflip. The upgrade() function controls our character's powerup, first the power level of our character is checked (Global.player_level), if it is at the maximum level (2), we simply return from the function without doing anything, so the character does not exceed the maximum level, then we check if the character is at level 0, if so we increase the player's score by 500, the shooting distance by 20 and change the shooting type “shoots” to “shoot02”, if none condition is met, we change the shooting type to shoot03 and increase the player's score by 3000, continuing to play the powerup sound, deactivate the current level's animations, increase the character's level, update the character's animations and sounds according to the new level, we make the animation visible, we also update the horizontal and vertical inversions of the current animation, we play the transformation animation, we enable the animation lock for a second and finally we increase the power of the shot.  
The last function of our character and perhaps the longest is get_damage(), which is activated every time our character receives some damage, we start the function by calling the global function HitStop and passing the value 0.5 seconds, this function leaves the time slower by half a second and works by changing the engine's time scale from 1 to 0.1 so time passes 90% slower, then we create the function get_tree().create_timer(time,true,false,true).timeout, This function creates a timer with the elapsed time (0.5) and using the word await we make the code below this line only run when the timer runs out, finally we restore the time scale to 1. Continuing we apply a vertical impulse to our character “velocity.y = death_hop.y”, if the character's level is at 0 we call the death() function explained previously and return from our function, continuing we disable the visibility of the current animation so we can update -there, we check our character's level and according to the level, we instantiate a downgrade item, update its position so that it is equal to our character's global position and add the item to the scene, we also update the shooting type “shoots ”, and in case the player is level 1 we also decrease the shooting distance by 20, then we reproduce the sound of the player being injured, we decrease their level, we update the sounds and animations according to the new level, we make the current animation visible , we corrected horizontal and vertical inversions and decreased firing power.  
our character to be discussed is _ready() this function is executed only once after our character is loaded and ready for use, its purpose is to finish making the necessary settings, it checks the phase in which we play and if it is phase 1, we enable the power to invert gravity, otherwise this ability remains turned off, we define the gravity scale, player level and horizontal inversion to their default, fill in their animation and sound arrays, and select the sounds and current animations (array position 0) and also select its shoot.  

Camera and the camera logic

The camera is a simple object, composed of the camera node and an image node (sprite2d) to simulate the flash, it follows our character and controls what we can see, it has few variables “shake_intensity” that controls the intensity that the camera will shake, “shake_duration” which controls the duration of the camera shake, “camera_limit” which defines the maximum distance from the camera, “camera_speed” controls the camera movement speed and “camera_distance” is the distance from the camera to our character. Just below we have its functions: shake(delta) this function makes the screen shake, it works by checking if the camera time (Global.caremaTimeElapsed) is less than the shaking time (shake_duration), then we use the randf_range() function to generate random numbers based on the intensity of how much the camera should shake, we store these numbers in X and Y and use them to change the position of the camera each frame making it shake, finally we increase the timer (Global.caremaTimeElapsed) by delta so that the camera does not shake forever. The _ready() function prepares the camera by increasing the timer to be greater than the shake time, so that the camera does not shake once it is ready. The flash(delta) function creates a white flash on the screen, it works by checking if the flash time (Global.flash_time) is greater than 0 and in this case it makes the flash visible and subtracts the delta from its timer (Global.flash_time), when the time runs out the flash visibility is disabled. The last function _process() adjusts the position of the camera in front of the character to improve its visibility. It works by checking the side the character is facing and then increasing the distance from the camera until it reaches the limit distance. Remember that the camera moves using the speed defined previously. Below, we define the global position of the camera as being equal to the global position of the character plus the distance from the camera. Finally, we call the shake(delta) and flash(delta) functions explained previously.  

Coin  

One of the items available in our game are coins, they are composed of a Node2D, a rigidbody2d which is a node with the objective of simulating an object moved by physics, a CollisionShape2D which will determine the collision area of ​​our object, a Sprite2D which will display the image of our object, the AnimationPlayer node which we will use to animate our object and the AudioStreamPlayer2D node which will be responsible for emitting the sound of our coin.  
The script that controls this item inherits from Node2D and has the following variables, vanish_timer which will serve as a timer, time_to_vanish which determines the time for the coin to disappear and particles which is a particle system. The first function we have is _ready() which prepares our item to be used, this function first completely stops the animation, chooses a random tone for the sound, chooses a random time for the coin to disappear, then we use the function mentioned above which creates a timer and waits until it ends to execute the code below, the following code plays the animation of the coin disappearing. The call_particles() function uses the particles variable to instantiate our particle system and adds it to the level in the same position as the coin. The play_sound() function simply plays the sound of our coin. The function _on_audio_stream_player_2d_finished(): causes the player's score to increase by 50 as soon as the audio finishes playing and the coin to leave the level. The function apply_impulse(impulse:Vector2) receives a Vector2 that has a horizontal and vertical force and uses these values ​​to apply an impulse using the rigidbody2 node function and finally we have the function _physics_process(_delta) that updates our gravity scale so that our coin can react accordingly even with inverted gravity.  

Coin Block and Suprise Block  

Another item is the coin block that when hit by the player releases several coins. This item is composed of nodes already discussed previously, namely: node2D, 2 Sprite2D, ColissionShape, AnimationPlayer and the StaticBody2D node which is a physical object that is not affected by other objects only by code, being generally used by fixed objects, such as floors and platforms. The variables present here are animation which will manage our animations, is_empty indicates whether the block is empty, coins are the coins explained above, impulse which defines the position to start the impulse, variance_rate which will be used to define a random force value, and impulse_force which will be the base impulse force. This is a simple object that has only one function responsible for playing the animation and adding the coins to the level, the get_hit(direction) function, receives a Vector2 type direction that serves to determine the direction of the coins and the animation. First, the direction is checked and an animation is selected accordingly. Then, it is checked whether the block is empty and, if so, the function stops being executed there. Continuing, we have a loop that is performed 10 times. Within this loop, we increase the player's score by 20. We instantiate a coin, define its direction of origin according to the direction and impulse. We determine the variation of the impulse force. We apply the impulse to the coin using its base impulse plus the variation and direction. We add the coin to the level. We change the image of our object, making one image visible and the other invisible. Finally, we define our block as empty.  
Our surprise block item is similar to the previous item, changing only a few things in its script. In it, we also have a variable responsible for the animation (animation), one that determines if it is empty (is_empty), two variables that represent powerup items (shell01 and shell02), and the impulse variable that determines the initial distance. This script also has the get_hit(direction) function, but with a few changes. The beginning remains the same, where the function receives a direction, reacts accordingly, and checks if the block is empty. Just below, a variable is created to store some of the power ups (shell). Then, we check the player's level. If they are at the initial level, shell01 will be chosen. In the other cases, shell02. We continue adding the item to the stage based on the impulse and direction. Finally, we change the image of the item and define it as empty.  

Downgrade1 and Downgrade2  

The items downgrade1 and downgarde2 are practically the same, changing only their image. Both items are composed only with the Sprite2d node. Their variables are initial_position, which is responsible for the initial position of our object, gravity, which defines the gravity that will affect our item, rotation_velocity, which defines the rotation speed of our object, velocity, which defines the initial speed of vertical movement, and dispawn_distance, which defines the distance that will make our item disappear. These items have two simple functions: _ready(), which defines their initial position and their disappearance position, and _process(delta), which defines their behavior. This function works by applying the initial velocity, gravity, and rotation, all multiplied by delta. Finally, we check if the disappearance distance has been exceeded, and in this case, we remove the object from the level.  

Jumping Enemy  

One of the opponents we will encounter in the game stays jumping in place, it is composed of an Area2D, an AnimatedSprite2D and a ColisionShape2D. Its variables are particles which is a particle system, dead_parts which are some parts of the character, origin_point which determines where the character will be, velocity which is the movement speed, jump_impulse which determines the strength of the jump, custom_gravity which determines the gravity that affects the character, jump_timer which will serve as a timer and time_to_jump which determines the time it takes for the character to jump. The first function we will see is get_hit(direction), it is triggered when the enemy is hit by the player, this function receives a direction of type Vector2, first a particle is instantiated, we configure such emission, lifetime, position and then we add it to the phase. Then we instantiate the enemy parts, configure its position, direction, increase the number of kills, score, add the enemy parts to the phase and remove the enemy from the phase. The jump function makes the enemy jump, it simply checks if it is time to jump and then adds a vertical impulse, the apply gravity function applies gravity to our character, it checks if the character is above the point of origin and if so, it applies gravity, otherwise its vertical speed is canceled, thus preventing the character from leaving its point of origin, the my_timer(delta) function has a similar operation, it controls the interval between jumps, it checks if the character is in the initial position or below and then accumulates time using delta, if the character is not at the point of origin because he jumped, the time is reset. The _ready() function prepares the character by reproducing its animation and defining its initial position, the _physics_process(delta) function is called in each loop, it applies vertical acceleration to the character and calls all the functions explained above except _ready(), finally the _on_body_entered(body) function is activated when the player comes into contact, this function causes damage to the player, this function checks if the object we collide with has the get_damage() function, which is exclusive to the player, and if so, the method is triggered.  

Life

The life item increases the player's life, its operation is extremely simple, it is composed of a node2d, a RigidBody2d, a CollisionBox, an Area2D with a Collision Box and a Sprite2D, this has only one function _on_area_2d_body_entered(body), which checks if the collision object “body” has the upgrade() function and if so, it increases the player's life by 1 and then leaves the level.  

Shell Enemy  

This is an enemy that cannot be defeated by shooting and is composed of a CharacterBody2D with a CollisionShaped2D, two Area2D each with a CollisionShape2D, an animatedSprite2D and an AudioStreamPlayer2D. Its variables are is_shield_mode which defines whether it is in defensive mode, shield_mode_timer which serves as a timer for defensive mode, shield_mode_duration which defines the duration of defensive mode, shield_mode_impulse which defines the speed in defensive mode after being hit, shield_mode_velocity which is the speed during defensive mode, is_flipped which defines whether it is horizontally inverted, gravity which is the gravity, which is the speed when on the ground, air_impulse which defines the impulse that throws it into the air, and bouce_force which is the force used to throw the player upwards. Its functions are death_animation() which is activated during its defeat, it works by adding a vertical impulse and deactivating the collision capacity, the get_hit(direction) function is activated when hit by the player, this function works by receiving a direction and checking if the enemy is in shield mode and according to the direction received, it applies an impulse according to the direction (left or right), if the direction is neither left or right and is in shield mode nothing is done, if it is not in shield mode it is only checked if the direction is left or right and then a horizontal impulse upwards is applied according to the direction and we stop the animation.  
The check_shield_mode(delta) function checks the behavior during shield mode, it works by checking if the shield mode speed is different from zero and if so, it applies that speed to the character and then ends the function. However, if there is no speed, we then check if the shield mode duration is greater than zero and if so, we subtract delta from the remaining time. However, if there is no remaining time, we deactivate shield mode and reactivate the Hitbox (the area responsible for hitting the player). The flip function is responsible for reversing the direction when necessary, it works by checking if the horizontal speed is zero and if it is not in shield mode, if so, we invert the ground speed and also the animation. The check_death() function checks if the enemy has been defeated, it works by checking the vertical position and if a certain distance is exceeded, we increase the kill counter, the player's score and remove that enemy from the stage. The walk() function is also simple, it checks if the character is not in shield mode and if it is on the floor or ceiling, then, the walking animation is played and the walking speed is applied according with gravity. The apply_forces(delta) function is responsible for applying horizontal and vertical forces according to gravity, the _physics_process(delta) function is called in each loop, it checks global gravity and rotates the character accordingly and the check_shield_mode(delta), walk(), apply_forces(delta), flip(), check_death() functions explained above are also called. Moving on to the last 3 functions, the _on_hurt_box_body_entered(body) function enters shield mode, it works by checking if the object with which the collision occurred has the (“activate_shoot”) method, if it does, a vertical impulse is applied to it, it switches to shield mode animation, activates shield mode, changes the speed to zero and plays the corresponding sound. The _on_hit_box_body_entered(body) function works by hitting obstacles during the movement of shield mode or reversing the direction during collision, it works by checking if the body with which it collided has the “get_damage” function and if the speed is not zero, if so, it calls the function, it also checks if the body has the “get_hit” function and again if the speed is not zero, if so, it calls the function, passing a direction according to the movement, if the body does not have any of the functions, we just check if it is in shield mode or solo and reverse the speed. In the case of solo mode, we also reverse the animation horizontally. Lastly, the _on_hit_box_area_entered(area) function: checks if there was a collision with a shield enemy and eliminates it. This function checks if the area it collided with has the “death_animation” function and if it is moving during shield mode, in this case, we call the function.  

Shoot areas  

The player has the ability to fire his weapon, each level has its shot for this we use the "SHOOT_AREA" where each number represents the player's level, these are composed of the Area2D, CollisionShape2D and AnimateSprite2D nodes. It script has only one variable "direction" which is of type Vector2, just below we have its functions: _ready() which is activated as soon as this resource is added to the level, this function reproduces the animation created by me, the _on_body_entered(body) function is activated as soon as a body enters our shooting area (Area2D) and is responsible for causing damage to opponents, it works by checking if the body that entered the area has the "get_hit" function and then calls this function passing the direction received then calls the Global.HitStop function which slows down time by 0.05 seconds. The last two functions are very simple, the on_animated_sprite_2d_animation_finished() function: is activated when the animation ends and removes the shoot from the phase, and the _on_area_entered(area) function: calls the _on_body_entered(body) function explained above passing the received area as an argument.  

Spike enemy  

This is a simple enemy that should not be touched. To defeat it, you need to attack from a distance. It consists of a CharacterBody2D with a CollisionShape2D, an AnimatedSprite2D and an Area2D with a CollisionShape2D. Its variables are “particles” which stores the emitted particles, dead_parts which stores the body parts added to the stage when the enemy is defeated, gravity which is gravity, is_flipped which controls which way it is facing and walk_speed which contains the movement speed. This enemy has few functions, the first being get_hit(direction) this function is activated when hit by the player, it works first by instantiating the particles, configuring their emission, position and adding them to the stage, then we also instantiate the “dead_parts”, configuring their direction, position, increasing the player's score and kill count and finally removing this enemy from the stage. The _ready() function simply makes the animation start playing as soon as possible. The _physics_process(delta) function applies gravity taking into account its scale, makes it move, checks if the vertical limits have been exceeded and then removes it from the scene if so and inverts the direction of the animation vertically depending on the gravity scale. The last function _on_area_2d_body_entered(body) checks what was collided with if the body has the “get_damage” function (exclusive to the player) we call it, otherwise we change the direction of the animation and movement speed.  

Standard enemy  

This is the most basic enemy in the game, it just walks from one side to the other, it is composed of the nodes CharacterBody2D with a CollisionShape2d, 2 Areas2D with CollisionShape2d, an AnimatedSprite2D and an AudioStreamPlayer2D. Its variables are: gravity responsible for gravity, is_flipped which controls which way the character is facing, bounde_force which controls the force with which the player bounces when jumping on top, dead_parts which stores some parts of this character, particles which is the particle system, is_dead which controls whether the character is alive or not and walk_speed which controls the movement speed.  
The _physics_process(delta) function is responsible for its movement, it works by adding gravity to its vertical speed taking into account the gravity scale, then we check if it is not dead and then make it move, otherwise we reset the speed and stop its animation , just below we check the gravity scale and turn it vertically according to the gravity, lastly we check its vertical limit and if it has exceeded this limit we remove it from the phase. The get_hit(direction) function is activated when hit by the player, we instantiate the particles, configure their duration, position and add them to the phase, we also instantiate the parts of the character, configure their position and direction and add them to the phase, we increase the player's score at 300 and kill counter at 1 and finally we remove the character from the phase. The _on_hurt_box_body_entered(body) method is activated when the player jumps on top of the character, first, we check if the body we collide with has the “activate_shoot” method and then we add a vertical impulse to this body, then, we change the character's vertical scale to 0.1 to give the impression of being flattened with the functions set_collision_layer_value(1,false), set_collision_layer_value(2,true), we change the character's collision layer so that it no longer interacts with the player, we also deactivate the Area2D nodes so that it does not detect or be detected, thus preventing it from causing or receiving unnecessary damage, finally, we play a sound corresponding to the act and define the character as dead, the last function _on_hit_box_body_entered(body) checks which body it collided with and reacts accordingly by changing direction or causing damage if it is the player, it simply checks if the collided body has the "get_damage" function and if this character is not dead and then calls the function, if it does not have the "get_damage" function we change the direction of movement.  

Dead bodys  

Some enemies are broken when defeated, so separate parts of these enemies are created and replace their bodies as soon as they are defeated. All “dead bodies” have the same composition and the same script, varying only their images and quantities. The nodes used are: a Node2D to group the nodes, several RigidBody2D combined with CollisionShape2D and Sprite2D, an AudioStreamPlayer2D node and a Timer are also used. The script is composed of the following variables: direction which controls the direction in which the parts will be propelled, impulse_force is the force used to propel the parts, impulse_variation is used to create different variations in the impulse force, and variation stores the variation created. Its functions are _ready() applies an impulse to each part as soon as it is added to the phase, it works by iterating through each of the nodes attached to Node2D and checking which one has the “apply_impulse” method, which in this case only RigidBody2D nodes have, after confirming the existence of the function we use the randf_range function to generate a random number using “impulse_variation” as a parameter and store this number in “variation”, then we use the apply_impulse function to apply the desired impulse taking into account the direction of the impulse force and its variation. The _on_timer_timeout() function makes the parts disappear from the phase as soon as the time stipulated in the node timer ends and the last function _physics_process(_delta) which is called whenever possible checks the gravity scale so that the parts can behave correctly, using the for child in get_children() function we iterate through each node attached to Node2D, we check which of these have the “apply_impulse” function and then we correct their gravity scale according to the global gravity.

Upgrades  

This is a rather simple item, it consists of a node2D responsible for grouping the other nodes, a RigidBody2D with a CollisionShape2D, an Area2D also with a CollisionShape2d and a Sprite2D. Its script has only 2 functions: _on_area_2d_body_entered(body) responsible for making the player transform upon contact, this function works by checking if the body with which the collision occurred has the upgrade method, if it does, it is activated and then we remove this item from the level. The _physics_process(_delta) function accesses the node attached at position 0 (RidigBody2D) and updates its gravity scale according to the global gravity scale.

Particles  

Just before disappearing completely, the coins emit some particles. This is done through the CPUParticles2D node. This node has some options so that we can create our particles in an interesting way. Through this, we can configure their quantity, lifetime, acceleration types, colors, textures, size and much more. For this particle system and others, we will not use textures, so only squares of varying color and size will be emitted. In this node, we will use a small script with the function of starting the particle emission and removing it from the phase as soon as the emission is finished. Our script has 2 functions: _ready(), which is called as soon as this resource is ready to be used in the phase. This function simply changes the particle property “emittig” from false to true, starting its emission. The second function, _on_finished(), is called when the emission is finished. This function calls the queue_free() function to delete the particle system from the phase, which will no longer be used.

Coin sound  

Just before disappearing, the coins emit a sound. To do this, the coin_sound resource is used. This consists only of the AudioStreamPlayer2D node, which is responsible for reproducing the sound we want positionally in relation to our character. Its script has only 2 functions: _ready(), which chooses a random tone between 0.9 and 1.1, and _on_finished(), which excludes this node from the level after its use is complete.  

Game over and ending  

Here we have the screen displayed at the end of our game, consisting of the nodes: node2D, used as a grouper, Sprite2D responsible for displaying the image, timer responsible for the maximum display duration and Camera2D responsible for the visible area. In addition to being the final screen, this scene is intended to restart the game in case the person wants to play again. This scene has only one variable (“intro”), which serves to store the intro scene. The functions here are restart() which restarts the game returning to the intro screen, this function calls the get_tree().change_scene_to_packed(intro) method, passing our only variable as a parameter changing the active scene to the intro scene, the _ready() function resets the score and the number of lives so that the game can be restarted properly, the _process(_delta) function has the function of checking if any button was pressed and if this happens the restart() function is called, the last function _on_timer_timeout() is triggered when the time configured in our timer node runs out and then calls the restart() function already explained above. The game over function has exactly the same composition and structure as the CS 50 Ending, changing only the image used and its display time, in this case being displayed when the player's number of lives reaches 0.  

HUD  

HUD or heads up display in a game is the part that contains information to be displayed to the user, such as number of lives and points. To create this interface we will use the CanvasLayer Node, this Node creates an independent rendering layer making the icons displayed on the screen relative to the position of the viewport, this way we can move our character freely and the information will always remain in the same place. To display the desired information (score, lives and kills) we will use a Label node for each piece of information. This node has a property called text of type string and displays the string information to the player. Our script consists of creating a string for each type of information. To do this, we will start with the title of each one (“Score:”, “Lifes:” and “Kills:”) Then we will access the “Global” class to find the desired information for each Label. Since the information is an integer, we will convert it to a string, concatenate it with its titles and assign the text property to each label so that it can be displayed to the player. We will do this inside the _process(_delta) function so that the information is always up to date. Finally, we can add a custom font to the Label node to style our text. Using the Minecraft.ttf font, we can give our text a pixel art style.  

Audio bus layout

To have better control over our in-game sound, we can create a custom sound channel layout, allowing us to control audio in general or by type, thus generating finer control. The main channel will be named Master and will control all sounds in general, then we will have two subchannels that will have their volume adjusted according to the Master channel, Music, responsible for controlling the volume of the game's music and SFX, responsible for controlling all sound effects. By configuring the channels in this way, simply configure which channel each sound will use so that we can control them using the desired channel.

First and second stage

Now that we have the player and enemy behaviors, the last thing we need to do to finish our game is to build its levels, to do this, we will use two resources: tileset and tilemap. A tile set is a set of images used to build scenarios and items in a game, it is usually a 2D image made up of smaller images of predefined sizes (tiles) that are used as small pieces in the assembly of a scenario, they can be used to build terrain, items, backgrounds, etc. The tilemap, in turn, allows the developer to position the tileset on the mesh, easily creating 2D maps, it can also be structured in layers, allowing for easier and more practical creation of scenarios, another function of the tilemap is to manage the collision of each tileset and render only the visible parts, making the use of resources more efficient.  
After creating the level as desired using the tools above, we also need to create limits so that the player and enemies move only within the delimited area. Another thing we need to create is an arrival point so that the player can win the level. After building the levels, positioning the player and opponents, we will create and position the arrival point, first, we will set up a flag at the end of the level to indicate the arrival point, then, we will create a 2D area to detect the player's arrival, we will also use the Area2D node to delimit the screen limits, this way, when the player or an opponent exceeds the area, we can react accordingly, to give it a special touch, we will add ambient music and a victory song that will be played when the player wins the level, to do this, we will use the AudioStreamPlayer node, finally, we will add a parallax effect to the game, this makes the background move at a different speed than the player, giving the impression of depth, to do this, we will add 3 nodes: ParallaxBackground, which is responsible for the parallax effect and can contain one or more layers, ParallaxLayer, which is responsible for representing one of the parallax layers, we will also need a 2D node to display the background image that will be displayed, finally, we have to configure the mirroring property, which defines when it will start the repetition of the background image and also the Scale property that defines the movement speed of the parallax layer.  
Since the enemies and the player are already ready, just use these tools to create the desired phases and then when the scenario is finished we will position the player and the enemies in the desired locations, finally we will create some scripts so that the phase can end and continue to the next one, end the game, etc. The script for our first phase has one variable and 4 functions, our only variable has the function of storing what the next phase will be, the _ready() function is called as soon as the phase starts, it determines the global level and loads the data for the next phase and stores it in the next_level variable. The _on_death_area_body_entered(body) function is activated when the player falls out of the stage and activates the player's death function, the _on_win_area_body_entered(body) function: is activated when the player reaches the end of the stage, this function changes the music and activates the player's win_game() function, finally the _on_win_music_finished() function: switches to the next stage and is activated when the victory music ends. In the script of the second phase we also have only one variable and four functions, the variable next_level stores the data of the game's ending screen, the functions _on_upper_death_area_body_entered(body): and _on_lower_death_area_body_entered(body): are responsible for eliminating the player or the opponent if they exceed the limit area, one function is activated when the upper limit is exceeded the other when the lower limit is exceeded, the function _on_area_2d_body_entered(body): is activated when the player reaches the end of the phase it changes the music and calls the player's win_game() function and finally the function _on_win_music_finished(): is activated when the victory music ends, calling the ending screen and thus ending the project.
